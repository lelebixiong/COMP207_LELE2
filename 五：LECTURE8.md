## Post Office Scandal
🧩 **Duplicated transactions（重复交易）**
这说明系统在处理交易时出现了 **重复记录** 的错误。在数据库中，如果两个记录拥有相同的“会话号”（相当于主键），那就应该只算作一笔操作。但该系统的不同模块之间没有一致的逻辑，有的算两笔，有的算一笔。


#### 🧠 涉及的 ACID 属性：
- **一致性（Consistency）** 被破坏：数据库的不同部分对同一交易的理解不一致。

- **原子性（Atomicity）** 被破坏：只有部分数据被更新，而不是“全部成功”或“全部失败”。


⚙️ **Atomicity / Consistency（原子性 / 一致性）**
终端（柜台）显示一切正常，但后台数据库仍保留了不一致的数据。这说明系统的不同部分在一次事务中更新的状态不一致。
#### 🧠 涉及的 ACID 属性：
- **一致性（Consistency）**：数据在终端和后台之间不一致。

- **原子性（Atomicity）**：事务没有“要么全成，要么全败”，只有一部分更新成功


🔒 **Isolation（隔离性）**
这表示两个用户的操作在时间上相互干扰。一个用户的报告可能漏掉另一用户刚执行的交易。  在一个理想的数据库系统中，**每个事务应该像是单独执行的**，不受他人影响。
#### 🧠 涉及的 ACID 属性：
- **隔离性（Isolation）** 被破坏：不同用户的操作互相干扰，产生了“时间窗口问题”。


💾 **Durability（持久性）**
系统在交易“完成”后未能正确保存结果。交易表面上完成了，但数据库没有永久记录下来。  当系统崩溃或出错后，已完成的事务应该仍然存在，而不是“丢失”。
#### 🧠 涉及的 ACID 属性：
- **持久性（Durability）** 被破坏：交易结果没有被永久保存。



## 🧱 一、Basic Locks（基本锁）
- 每个数据项（例如 X）就像有一个“挂锁”。
- 如果一个事务想操作它（读或写），它必须“上锁（lock）”，用完之后“解锁（unlock）”。
- 如果别的事务已经拿走了锁，就必须**等待**。
- 操作完成后要把锁**归还**。

**符号表示：**
- `l1(X)`：表示事务 T1 锁定数据项 X。
- `u1(X)`：表示事务 T1 解锁数据项 X。

T1: l1(X); read(X); write(X); u1(X)
T2: l2(X); read(X); u2(X)
→ T2 必须等到 T1 解锁后才能获得锁并操作 X。


## 🤝 二、Shared and Exclusive Locks（共享锁与排他锁）
### 🟦 1. 共享锁（Shared Lock, 简写 `sl`）
- 用于 **读取** 数据。
- 多个事务可以**同时持有共享锁**（即多个事务可以一起读）。
- 但不能与“排他锁”共存。

### 🟥 2. 排他锁（Exclusive Lock, 简写 `xl`）
- 用于 **写入** 数据。
- 只能有一个事务持有，其他任何锁（包括共享锁）都不能存在。
- 你可以在持有排他锁时同时读写。

**符号表示：**
- `sl1(X)`：事务 T1 对 X 上共享锁。
- `xl1(X)`：事务 T1 对 X 上排他锁。

T1: sl1(X); read(X); u1(X)
T2: xl2(X); write(X); u2(X)
→ T2 必须等待 T1 解锁后，才能获得排他锁。


## 🔁 三、Update Locks（更新锁）
在一些系统中，引入“更新锁（Update Lock, 简写 UL）”，用来防止两个事务都试图先读后写时产生“死锁（deadlock）”。
- 类似于共享锁（可以读数据），但表示“我可能要修改它”。
- 同一时间只能有**一个更新锁**。
- 更新锁可以**升级**成排他锁（exclusive lock）。
- 当一个事务持有更新锁时：
    - 其他事务 **不能再拿更新锁或排他锁**；
    - 但仍然可以有一些共享锁（已经存在的读操作）在进行。

⚠️ 非对称（Asymmetric）：如果你有一个更新锁，别人不能拿更新锁；但如果别人有共享锁，你仍然**可以等待他们结束后升级**为排他锁。

### 🧍‍♂️💬 Facebook 例子（理解更新锁）

想象你在 Facebook 上：
- 你有很多朋友，经常有人访问你的主页（读取数据）。
- 当你自己要发动态（写入数据）时，你需要：
    1. 先获得“更新锁”（告诉系统你打算修改）；
    2. 等到别人看完后（共享锁释放），你就能升级为“排他锁”来修改。
如果你一开始就申请“排他锁”，你可能**永远拿不到**，因为别人一直在看你的页面。  
这种“永远拿不到资源”的情况称为 **starvation（饥饿）**。


## 🌳 四、Multiple Granularity Locks（多粒度锁）
数据库为了兼顾效率与并发性，允许在多个层级上加锁：
- 可以对**整张表**加共享/排他锁；
- 也可以对**表中的单个记录**加共享/排他锁。
多粒度锁的难点：需要通过 **层级锁协议（Locking Hierarchy Protocol）** 来解决当你想给整个表加锁时，怎么知道表中是否已经有人锁住了某一行？难道要检查表中每一条记录吗？这一问题

CONCLUSION：
![[Pasted image 20251015114234.png]]


🧩 一、Intention Locks（意向锁），用来解决检查表中所有记录的表状态，即解决如果我想锁住一条表中的记录，但别人已经锁住了整个表，或者反过来怎么办？这一问题。
![[Pasted image 20251015114555.png]]
![[Pasted image 20251015114734.png]]

🔐 二、2PL（Two-Phase Locking，两阶段锁协议）
即在一个事务中，分为两个阶段:
- **扩展阶段（Growing phase）**：可以加锁，不能解锁；
- **收缩阶段（Shrinking phase）**：可以解锁，但不能再加新锁。
→ 这样可以保证事务的执行是 **冲突可串行化（conflict-serializable）** 的。

T1: l1(X); l1(Y); read(X); write(Y); u1(X); u1(Y)
✅ 所有加锁都在解锁之前完成 → 满足 2PL  → 事务执行的结果等价于串行执行。


MYSQL里面支持共享锁，排他锁，多粒度锁，并使用了2PL协议，但是值得注意的是，他没有更新锁。