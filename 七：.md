事务的隔离级别（Isolation Levels）
	--- Read Uncommitted（读未提交）任何行为都是允许的（但是不能出现在脏读）
	---Read Committed（读已提交）只能**读取或修改已经提交的数据**。
	---**Repeatable Read（可重复读）**（⚠️ 重点、常考）如果你在事务中**第一次读到的数据**，在这个事务结束前，**每次再读都应该是一样的**（除非你自己修改了它）。
	---Serializable（可串行化）满足 **Repeatable Read** 的所有要求，并且**事务的行为要等价于一个串行调度（serial schedule）**。⚠️ 冲突可串行化（conflict-serializable）并不一定意味着可重复读



锁🔒（Lock）
- **共享锁（Shared Lock，S）** – 用于**读操作**
    - 可以有**多个共享锁同时存在**（多个事务可以同时读）。
    - 但如果有“更强”的锁（如排他锁）存在，就不能加共享锁。
        
- **排他锁（Exclusive Lock，X）** – 用于**写操作**
    - **同一时间只能有 1 个排他锁**，并且有排他锁时，其他锁都不能加。
    - 拥有排他锁的事务不仅能写，还能读。
        
- **更新锁（Update Lock）** – 类似共享锁，但可以**升级为排他锁**
    - 一次只能有 1 个更新锁。
    - 如果其他事务持有共享锁，不冲突。
    - 常用于防止“死锁”。
        
- **意向锁（Intention Lock）** – 表示“我**打算**对表中某一行加锁”
    - 本身**没有控制力**，但它的存在使数据库能够快速判断是否可以在更大范围（如整个表）上加锁。
    - 你可以把“对表的共享/排他锁”看作是“对表中所有行加了共享/排他锁”。

